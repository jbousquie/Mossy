
-- SETTINGS
local WALK_VEL = 400
local JUMP_VEL = 800
local GRAVITY = 1000
local MAX_Y_VEL = 2000

-- STATES 
local STATE_IDLE = hash("idle")
local STATE_WALK = hash("walk")
local STATE_JUMP = hash("jump")

-- INPUTS
local RIGHT = hash("right")
local LEFT = hash("left")
local JUMP = hash("jump")

-- OTHER CONSTs
local CONTACT_POINT = hash("contact_point_response")
local LEVEL_GROUP = hash("level")


function init(self)
	msg.post("#", "acquire_input_focus")
	self.velocity = vmath.vector3(0, 0, 0)
	self.direction = 1
	self.on_ground = false
	self.state = STATE_IDLE
	self.correction = vmath.vector3(0, 0, 0)
end



local function clamp(val, min, max)
	if val < min then return min 
	elseif val > max then return max
	else return val
	end
end

-- add v2 in place to v1
local function add_in_place(v1 ,v2)
	v1.x = v1.x + v2.x
	v1.y = v1.y + v2.y
	v1.z = v1.z + v2.z
end


function fixed_update(self, dt)

	if self.on_ground then
		self.velocity.y = 0
	else 
		-- apply GRAVITY
		self.velocity.y = self.velocity.y - GRAVITY * dt 
		self.velocity.y = clamp(self.velocity.y, -MAX_Y_VEL, MAX_Y_VEL)
	end
	
	local pos = go.get_position()
	add_in_place(pos, self.velocity * dt)
	go.set_position(pos)

	self.velocity.x = 0
	self.on_ground = false
	
end

function manage_collisions(self, message)
	local normal = message.normal
	local distance = message.distance

	if distance > 0 then
		local projection = vmath.project(self.correction, normal * distance)
		if projection < 1 then
			local compensation = (distance - distance * projection) * normal
			go.set_position(go.get_position() + compensation)
			self.correction = self.correction + compensation
		end
	end

	-- level on left or right 
	if math.abs(normal.x) > 0.7 then
		self.velocity.x = 0
	end

	-- hit the ground
	if normal.y > 0.7 then
		self.on_ground = true
		self.velocity.y = 0
	end

	-- hit a ceiling
	if normal.y < 0.7 then
		self.velocity.y = 0
	end
end


function on_message(self, message_id, message, sender)
	if message_id == CONTACT_POINT and message.group == LEVEL_GROUP then
		manage_collisions(self, message)
	end
end

function flip(self)
	sprite.set_hflip("#sprite", self.direction < 0)
end

-- move horizontally
function move_h(self)
	flip(self)
	self.velocity.x = WALK_VEL * self.direction
	if self.on_ground then 
		self.state = STATE_WALK
	end
end

-- init jump
function jump(self)
	self.on_ground = false
	self.velocity.y = JUMP_VEL
	self.state = STATE_JUMP
end

function on_input(self, action_id, action)
	if action_id == RIGHT then
		self.direction = 1
		move_h(self)
	elseif action_id == LEFT then
		self.direction = -1
		move_h(self)
	elseif action_id == JUMP and self.on_ground then
		jump(self)
	end
end

